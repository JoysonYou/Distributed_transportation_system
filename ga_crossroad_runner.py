"""
遗传算法优化的十字路口仿真
使用遗传算法演化交通通行策略
"""
import os
import sys
import traci
import time

# 导入遗传算法模块
from ga_traffic_strategy import GeneticTrafficStrategy, GeneticAlgorithmOptimizer

# --- SUMO环境配置 ---
if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    sys.exit("请设置环境变量 'SUMO_HOME'")


class VehicleGenerator:
    """
    Dummy generator class - vehicles are now generated by SUMO flows in crossroad.rou.xml
    This class is kept for compatibility but does nothing.
    """
    def __init__(self, step_interval=None):
        # No longer needed - SUMO handles vehicle generation
        pass
        
    def update(self, step):
        """No-op - SUMO flows handle vehicle generation automatically"""
        pass


class GADrivingStrategy:
    """
    基于遗传算法的驾驶策略 - 修复版
    正确检测车道对应的红绿灯状态
    """
    MAX_SPEED = 20.0
    MIN_SPEED = 0.0
    
    # 安全参数
    STOP_LINE_DISTANCE = 2.0      # 停车线安全距离(m)
    SAFE_STOPPING_DECEL = -3.0    # 安全制动减速度(m/s^2)
    EMERGENCY_DECEL = -4.5        # 紧急制动减速度(m/s^2)
    MIN_SAFE_GAP = 3.0            # 最小安全车距(m)

    def __init__(self, ga_strategy: GeneticTrafficStrategy):
        """
        初始化驾驶策略
        
        Args:
            ga_strategy: 遗传算法训练出的策略
        """
        self.ga_strategy = ga_strategy
        self.initialized_vehicles = set()
        # 缓存车道到信号灯索引的映射
        self._lane_to_tl_index = {}

    def _is_red_for_lane(self, tl_state: str, lane_id: str, edge_id: str, tl_phase: int) -> bool:
        """
        判断特定车道是否是红灯
        使用交通灯相位来判断
        
        边命名规则: W_in, E_in, N_in, S_in
        
        Args:
            tl_state: 交通灯状态字符串
            lane_id: 车道ID
            edge_id: 边ID (如 W_in, E_in, N_in, S_in)
            tl_phase: 交通灯当前相位
            
        Returns:
            是否是红灯（需要停车）
        """
        if not tl_state:
            return False
        
        # 根据边ID判断方向
        # 边命名: W_in(西入), E_in(东入), N_in(北入), S_in(南入)
        is_east_west = edge_id.startswith('W') or edge_id.startswith('E')
        is_north_south = edge_id.startswith('N') or edge_id.startswith('S')
        
        # 使用相位判断（更可靠）
        # 典型的相位设置：
        # - 相位0,1: 东西向绿灯
        # - 相位2,3: 南北向绿灯
        # 但这取决于具体配置，所以我们也检查信号灯状态字符串
        
        # 信号灯状态字符串通常按连接顺序排列
        # 我们检查对应方向的任一灯是否为绿
        
        # 从车道ID提取车道编号 (如 "W_in_0" -> 0)
        try:
            lane_num = int(lane_id.split('_')[-1])
        except:
            lane_num = 0
        
        # 根据边方向和信号灯状态判断
        # SUMO默认：东西向通常对应偶数相位，南北向对应奇数相位
        if len(tl_state) >= 4:
            # 尝试根据信号状态字符串的模式判断
            # 计算各方向的绿灯数量
            green_count = sum(1 for c in tl_state if c in 'Gg')
            red_count = sum(1 for c in tl_state if c in 'Rr')
            
            # 如果大部分是红灯，说明只有少数方向是绿灯
            # 检查具体哪个方向
            
            # 方法1：检查相位
            # 相位0,1通常是东西向（或一组对向），相位2,3是南北向（另一组）
            if tl_phase in [0, 1]:
                # 东西向绿灯
                return is_north_south
            elif tl_phase in [2, 3]:
                # 南北向绿灯
                return is_east_west
            else:
                # 其他相位（可能是全红或过渡），保守处理
                # 检查状态字符串中该方向的灯
                pass
        
        # 方法2：直接检查信号灯状态字符串
        # 假设前几个字符对应一个方向，后几个对应另一方向
        n = len(tl_state)
        if n >= 2:
            # 简单分割：前半对应东西向，后半对应南北向（或反过来）
            half = n // 2
            
            if is_east_west:
                # 检查前半部分（东西向）
                relevant_state = tl_state[:half]
            else:
                # 检查后半部分（南北向）
                relevant_state = tl_state[half:]
            
            # 如果该方向有绿灯，则不是红灯
            if any(c in 'Gg' for c in relevant_state):
                return False
            else:
                return True
        
        # 最后的保守策略：如果不确定，返回False（假设绿灯）
        return False

    def _calculate_stop_distance(self, speed: float, decel: float = -3.0) -> float:
        """计算制动距离: d = v^2 / (2 * |a|)"""
        if speed <= 0:
            return 0.0
        return (speed * speed) / (2 * abs(decel))

    def _get_safe_speed(self, distance: float, current_speed: float) -> float:
        """
        计算在给定距离内能安全停车的最大速度
        v = sqrt(2 * |a| * d)
        """
        if distance <= 0:
            return 0.0
        safe_speed = (2 * abs(self.SAFE_STOPPING_DECEL) * max(distance, 0.1)) ** 0.5
        return min(safe_speed, self.MAX_SPEED)

    def update(self, step: int):
        """在每个仿真步长调用此方法"""
        # 采样间隔检查 (0.2s = 2 steps)
        if step % 2 != 0:
            return

        # 获取红绿灯信息
        junction_id = "J0"
        try:
            tl_state = traci.trafficlight.getRedYellowGreenState(junction_id)
            tl_phase = traci.trafficlight.getPhase(junction_id)
        except traci.TraCIException:
            tl_state = ""
            tl_phase = -1

        # 获取车辆信息
        vehicle_ids = traci.vehicle.getIDList()
        
        for veh_id in vehicle_ids:
            if veh_id not in self.initialized_vehicles:
                traci.vehicle.setColor(veh_id, (255, 255, 0, 255))  # 黄色
                self.initialized_vehicles.add(veh_id)

            try:
                lane_id = traci.vehicle.getLaneID(veh_id)
                edge_id = traci.vehicle.getRoadID(veh_id)
                
                # 只处理进入路口的车辆
                if edge_id.endswith("_in"):
                    lane_len = traci.lane.getLength(lane_id)
                    lane_pos = traci.vehicle.getLanePosition(veh_id)
                    dist_to_junction = lane_len - lane_pos
                    speed = traci.vehicle.getSpeed(veh_id)
                    
                    # 正确判断该车道的红绿灯状态
                    is_red_light = self._is_red_for_lane(tl_state, lane_id, edge_id, tl_phase)
                    
                    # 检测前车距离
                    leader_data = traci.vehicle.getLeader(veh_id, dist=50.0)
                    leader_distance = float('inf')
                    if leader_data is not None:
                        leader_distance = leader_data[1]
                    
                    if dist_to_junction <= 30.0:
                        # 进入决策区域
                        
                        # ===== 安全检查 =====
                        
                        # 1. 红灯停车检查
                        if is_red_light and dist_to_junction < 15.0:
                            # 计算安全停车距离
                            stop_distance = self._calculate_stop_distance(speed)
                            available_distance = dist_to_junction - self.STOP_LINE_DISTANCE
                            
                            # 如果无法在停车线前停下，紧急制动
                            if available_distance > 0 and stop_distance >= available_distance * 0.9:
                                accel_cmd = self.EMERGENCY_DECEL
                                traci.vehicle.setSpeedMode(veh_id, 0)
                                new_speed = max(0.0, speed + accel_cmd * 0.2)
                                traci.vehicle.setSpeed(veh_id, new_speed)
                                continue
                        
                        # 2. 前车碰撞避免
                        if leader_distance < self.MIN_SAFE_GAP:
                            accel_cmd = self.EMERGENCY_DECEL
                            traci.vehicle.setSpeedMode(veh_id, 0)
                            new_speed = max(0.0, speed + accel_cmd * 0.2)
                            traci.vehicle.setSpeed(veh_id, new_speed)
                            continue
                        
                        # ===== 使用遗传算法策略 =====
                        accel_cmd = self.ga_strategy.get_action(dist_to_junction, speed, is_red_light)
                        
                        # 红灯时的安全限制
                        if is_red_light:
                            # 红灯时限制加速
                            if dist_to_junction < 10.0:
                                accel_cmd = min(accel_cmd, -1.0)
                            elif dist_to_junction < 20.0:
                                accel_cmd = min(accel_cmd, 0.0)
                        
                        # 设置为手动控制模式
                        traci.vehicle.setSpeedMode(veh_id, 0)
                        
                        # 根据加速度计算新速度
                        new_speed = max(self.MIN_SPEED, min(speed + accel_cmd * 0.2, self.MAX_SPEED))
                        
                        # 红灯时在停车线附近减速停车
                        if is_red_light and dist_to_junction < self.STOP_LINE_DISTANCE + 0.5:
                            new_speed = min(new_speed, 1.0)
                        
                        traci.vehicle.setSpeed(veh_id, new_speed)
                    else:
                        # 决策区域外，正常行驶
                        if leader_distance < self.MIN_SAFE_GAP * 2:
                            safe_speed = self._get_safe_speed(leader_distance - self.MIN_SAFE_GAP, speed)
                            traci.vehicle.setSpeedMode(veh_id, 0)
                            traci.vehicle.setSpeed(veh_id, max(0, min(safe_speed, self.MAX_SPEED)))
                        else:
                            traci.vehicle.setSpeedMode(veh_id, 31)
                            traci.vehicle.setSpeed(veh_id, self.MAX_SPEED)
                else:
                    # 在路口内或离开路口 - 使用默认行为
                    traci.vehicle.setSpeedMode(veh_id, 31)

            except traci.TraCIException:
                continue


class SimpleTrafficLightScheduling:
    """简单的交通灯调度"""
    def __init__(self, junction_id: str):
        self.junction_id = junction_id
        self.phase_index = 0
        self._phases = None

    @property
    def phases(self):
        if self._phases is None:
            try:
                self._phases = traci.trafficlight.getCompleteRedYellowGreenDefinition(self.junction_id)[0].phases
            except traci.TraCIException:
                pass
        return self._phases

    def update(self, step: int):
        if self.phases is None:
            return
        
        # 每30步切换一次交通灯相位
        if step > 0 and step % 30 == 0:
            self.phase_index = (self.phase_index + 1) % len(self.phases)
            traci.trafficlight.setPhase(self.junction_id, self.phase_index)


class FitnessEvaluator:
    """
    改进的适应度评估器 - 严格的闯红灯和碰撞检测
    运行一次完整的仿真，评估策略性能
    """
    def __init__(self, sumo_cmd, max_steps=3000, generation_interval=40, verbose=False):
        self.sumo_cmd = sumo_cmd
        self.max_steps = max_steps
        self.generation_interval = generation_interval
        self.verbose = verbose
        self.min_safe_distance = 3.0  # 最小安全距离(m)
        self.stop_line_distance = 2.0  # 停车线距离(m)
    
    def _is_red_for_vehicle(self, edge_id: str, tl_state: str, tl_phase: int) -> bool:
        """
        判断特定边上的车辆是否面对红灯
        
        Args:
            edge_id: 边ID (如 W_in, E_in, N_in, S_in)
            tl_state: 交通灯状态字符串
            tl_phase: 交通灯当前相位
            
        Returns:
            是否是红灯（需要停车）
        """
        if not tl_state:
            return False
        
        # 根据边ID判断方向
        is_east_west = edge_id.startswith('W') or edge_id.startswith('E')
        is_north_south = edge_id.startswith('N') or edge_id.startswith('S')
        
        # 使用相位判断
        # 相位0,1: 东西向绿灯, 相位2,3: 南北向绿灯
        if tl_phase in [0, 1]:
            return is_north_south
        elif tl_phase in [2, 3]:
            return is_east_west
        
        # 备用方法：检查信号灯状态字符串
        n = len(tl_state)
        if n >= 2:
            half = n // 2
            if is_east_west:
                relevant_state = tl_state[:half]
            else:
                relevant_state = tl_state[half:]
            
            if any(c in 'Gg' for c in relevant_state):
                return False
            else:
                return True
        
        return False
    
    def evaluate(self, strategy: GeneticTrafficStrategy) -> float:
        """
        评估策略的适应度 - 严格的闯红灯和碰撞检测
        
        Args:
            strategy: 要评估的策略
            
        Returns:
            适应度分数（越小越好）
        """
        # 启动仿真
        traci.start(self.sumo_cmd)
        
        # 创建驾驶策略和其他组件
        driving_strategy = GADrivingStrategy(strategy)
        traffic_light = SimpleTrafficLightScheduling(junction_id="J0")
        vehicle_generator = VehicleGenerator(step_interval=self.generation_interval)
        
        # 记录统计数据
        total_waiting_time = 0.0
        total_travel_time = 0.0
        vehicle_finish_times = {}
        vehicle_start_times = {}
        
        # 安全性统计
        collision_count = 0
        near_miss_count = 0
        emergency_brake_count = 0
        
        # 闯红灯统计
        red_light_violation_count = 0
        red_light_approach_penalty = 0.0
        
        # 车辆状态追踪（用于检测闯红灯）
        vehicle_last_position = {}  # 记录上一步的位置
        vehicle_crossed_stop_line = set()  # 记录已经过停车线的车辆
        
        step = 0
        try:
            while step < self.max_steps:
                traci.simulationStep()
                
                # 更新各个组件
                driving_strategy.update(step)
                traffic_light.update(step)
                vehicle_generator.update(step)
                
                # 获取当前交通灯状态
                try:
                    tl_state = traci.trafficlight.getRedYellowGreenState("J0")
                    tl_phase = traci.trafficlight.getPhase("J0")
                except:
                    tl_state = ""
                    tl_phase = -1
                
                # 收集统计数据
                vehicle_ids = traci.vehicle.getIDList()
                
                for veh_id in vehicle_ids:
                    try:
                        # 记录开始时间
                        if veh_id not in vehicle_start_times:
                            vehicle_start_times[veh_id] = step
                        
                        speed = traci.vehicle.getSpeed(veh_id)
                        accel = traci.vehicle.getAcceleration(veh_id)
                        lane_id = traci.vehicle.getLaneID(veh_id)
                        edge_id = traci.vehicle.getRoadID(veh_id)
                        
                        # 累计等待时间
                        if speed < 0.1:
                            total_waiting_time += 0.1
                        
                        # 检测紧急制动
                        if accel < -3.5:
                            emergency_brake_count += 1
                        
                        # ===== 碰撞检测 =====
                        leader_data = traci.vehicle.getLeader(veh_id, dist=50.0)
                        if leader_data is not None:
                            leader_id, distance = leader_data
                            
                            if distance < self.min_safe_distance:
                                collision_count += 1
                            elif distance < self.min_safe_distance * 2:
                                near_miss_count += 1
                            
                            if distance < 8.0 and speed > 8.0:
                                near_miss_count += 0.5
                        
                        # ===== 闯红灯检测 =====
                        if edge_id.endswith("_in"):
                            lane_len = traci.lane.getLength(lane_id)
                            lane_pos = traci.vehicle.getLanePosition(veh_id)
                            dist_to_junction = lane_len - lane_pos
                            
                            # 获取该边的红绿灯状态（使用相位）
                            is_red = self._is_red_for_vehicle(edge_id, tl_state, tl_phase)
                            
                            # 记录上一步位置
                            prev_dist = vehicle_last_position.get(veh_id, dist_to_junction + 1)
                            vehicle_last_position[veh_id] = dist_to_junction
                            
                            # 检测闯红灯
                            if is_red:
                                # 红灯时越过停车线
                                if prev_dist > self.stop_line_distance and dist_to_junction <= self.stop_line_distance:
                                    if veh_id not in vehicle_crossed_stop_line:
                                        red_light_violation_count += 1
                                        vehicle_crossed_stop_line.add(veh_id)
                                
                                # 红灯时高速接近
                                if dist_to_junction < 10.0 and speed > 5.0:
                                    red_light_approach_penalty += speed * 0.3
                                
                                if dist_to_junction < 5.0 and speed > 3.0:
                                    red_light_approach_penalty += speed * 1.0
                        
                        # 在路口内的车辆 - 检测与其他车辆的距离
                        elif ':' in edge_id:  # 在路口内
                            # 检测与其他路口内车辆的距离
                            veh_pos = traci.vehicle.getPosition(veh_id)
                            for other_id in vehicle_ids:
                                if other_id != veh_id:
                                    try:
                                        other_edge = traci.vehicle.getRoadID(other_id)
                                        if ':' in other_edge:  # 另一辆也在路口内
                                            other_pos = traci.vehicle.getPosition(other_id)
                                            dist = ((veh_pos[0] - other_pos[0])**2 + 
                                                   (veh_pos[1] - other_pos[1])**2)**0.5
                                            if dist < self.min_safe_distance:
                                                collision_count += 0.5
                                            elif dist < self.min_safe_distance * 2:
                                                near_miss_count += 0.3
                                    except:
                                        pass
                    
                    except traci.TraCIException:
                        continue
                
                # 检查完成的车辆
                arrived_ids = traci.simulation.getArrivedIDList()
                for veh_id in arrived_ids:
                    if veh_id in vehicle_start_times and veh_id not in vehicle_finish_times:
                        vehicle_finish_times[veh_id] = step
                        travel_time = (step - vehicle_start_times[veh_id]) * 0.1
                        total_travel_time += travel_time
                    # 清理追踪数据
                    vehicle_last_position.pop(veh_id, None)
                    vehicle_crossed_stop_line.discard(veh_id)
                
                # 检查SUMO内部碰撞检测
                try:
                    teleport_ids = traci.simulation.getStartingTeleportIDList()
                    collision_count += len(teleport_ids) * 3  # teleport严重惩罚
                except:
                    pass
                
                try:
                    colliding_ids = traci.simulation.getCollidingVehiclesIDList()
                    collision_count += len(colliding_ids) * 2
                except:
                    pass
                
                step += 1
                
        except traci.exceptions.TraCIException as e:
            if self.verbose:
                print(f"    仿真错误: {e}")
            traci.close()
            return 50000.0  # 仿真错误惩罚更高
        
        traci.close()
        
        # 计算适应度分数
        num_finished = len(vehicle_finish_times)
        num_started = len(vehicle_start_times)
        
        if num_finished == 0:
            fitness = 50000.0
        else:
            # 基础指标
            avg_travel_time = total_travel_time / num_finished
            avg_waiting_time = total_waiting_time / num_finished
            completion_rate = num_finished / max(num_started, 1)
            
            # 适应度 = 加权组合（大幅提高安全性权重）
            fitness = (
                # 效率指标
                avg_travel_time * 1.0 +
                avg_waiting_time * 1.0 +
                
                # 碰撞惩罚（极高权重）
                collision_count * 500.0 +
                near_miss_count * 50.0 +
                
                # 闯红灯惩罚（极高权重）
                red_light_violation_count * 1000.0 +
                red_light_approach_penalty * 20.0 +
                
                # 驾驶舒适性
                emergency_brake_count * 1.0 +
                
                # 完成率惩罚
                (1.0 - completion_rate) * 200.0
            )
        
        if self.verbose:
            print(f"    完成: {num_finished}/{num_started}, 行驶: {avg_travel_time:.1f}s, 等待: {avg_waiting_time:.1f}s")
            print(f"    碰撞: {collision_count:.1f}, 险情: {near_miss_count:.1f}")
            print(f"    闯红灯: {red_light_violation_count}, 红灯接近惩罚: {red_light_approach_penalty:.1f}")
            print(f"    适应度: {fitness:.1f}")
        
        return fitness


def train_ga_strategy(generations=15, population_size=30):
    """
    训练遗传算法策略（改进版）
    
    Args:
        generations: 演化代数（增加到15）
        population_size: 种群大小（增加到30）
    """
    print("\n" + "="*70)
    print("遗传算法交通策略训练 - 改进版")
    print("="*70)
    
    # SUMO配置（使用无GUI模式加快训练）
    sumoBinary = "sumo"  # 使用命令行版本，不显示GUI
    sumoCmd = [sumoBinary, "-c", "crossroad.sumocfg", 
               "--no-warnings", "--no-step-log", 
               "--collision.action", "warn",  # 启用碰撞警告
               "--time-to-teleport", "300"]   # 增加teleport时间，更好地检测死锁
    
    # 创建适应度评估器
    fitness_evaluator = FitnessEvaluator(
        sumo_cmd=sumoCmd,
        max_steps=2500,  # 稍微延长以评估更多车辆
        generation_interval=60,
        verbose=False
    )
    
    # 创建遗传算法优化器（使用改进的参数）
    ga_optimizer = GeneticAlgorithmOptimizer(
        population_size=population_size,
        mutation_rate=0.2,      # 提高初始变异率
        crossover_rate=0.8,     # 提高交叉率
        elite_size=3,           # 保留更多精英
        adaptive=True           # 启用自适应机制
    )
    
    # 执行演化
    start_time = time.time()
    print(f"\n开始演化训练...")
    print(f"预计时间: ~{generations * population_size * 15 / 60:.1f} 分钟")
    ga_optimizer.evolve(fitness_evaluator.evaluate, generations=generations)
    end_time = time.time()
    
    elapsed_time = end_time - start_time
    print(f"\n训练完成！")
    print(f"总用时: {elapsed_time:.2f} 秒 ({elapsed_time/60:.1f} 分钟)")
    
    # 保存最佳策略
    best_strategy = ga_optimizer.get_best_strategy()
    best_strategy.save("best_ga_strategy.pkl")
    
    # 保存演化历史
    ga_optimizer.save_history("ga_history.pkl")
    
    # 绘制演化曲线
    ga_optimizer.plot_history("ga_evolution.png")
    
    print(f"\n最佳策略已保存到: best_ga_strategy.pkl")
    print(f"演化历史已保存到: ga_history.pkl")
    print(f"演化曲线已保存到: ga_evolution.png")
    
    return best_strategy


def test_strategy(strategy: GeneticTrafficStrategy, use_gui=True):
    """
    测试训练好的策略
    
    Args:
        strategy: 要测试的策略
        use_gui: 是否使用GUI显示
    """
    print("\n" + "="*70)
    print("Testing Best Strategy")
    print("="*70)
    
    # 确保之前的连接已关闭
    try:
        traci.close()
    except:
        pass
    
    # SUMO配置
    sumoBinary = "sumo-gui" if use_gui else "sumo"
    sumoCmd = [sumoBinary, "-c", "crossroad.sumocfg", "--start", "--quit-on-end", "false"]
    
    # 启动仿真
    print("Starting SUMO simulation...")
    traci.start(sumoCmd)
    
    # 创建组件
    driving_strategy = GADrivingStrategy(strategy)
    traffic_light = SimpleTrafficLightScheduling(junction_id="J0")
    vehicle_generator = VehicleGenerator(step_interval=40)
    
    step = 0
    max_steps = 5000
    
    print("Running simulation...")
    print("Press Ctrl+C or close SUMO window to stop.")
    
    try:
        while step < max_steps:
            traci.simulationStep()
            
            driving_strategy.update(step)
            traffic_light.update(step)
            vehicle_generator.update(step)
            
            step += 1
            
    except traci.exceptions.TraCIException as e:
        print(f"Simulation ended: {e}")
    except KeyboardInterrupt:
        print("\nSimulation interrupted by user.")
    finally:
        try:
            traci.close()
        except:
            pass
    
    print("Testing complete")


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(
        description='遗传算法交通策略优化 - 改进版',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用示例:
  训练新策略:
    python ga_crossroad_runner.py --mode train
    
  训练并测试:
    python ga_crossroad_runner.py --mode both
    
  仅测试已有策略:
    python ga_crossroad_runner.py --mode test
    
  自定义参数训练:
    python ga_crossroad_runner.py --mode train --generations 20 --population 40
        """
    )
    
    parser.add_argument('--mode', type=str, default='train', 
                        choices=['train', 'test', 'both'],
                        help='运行模式：train(训练), test(测试), both(先训练后测试)')
    parser.add_argument('--generations', type=int, default=15,
                        help='演化代数（默认15，建议10-30）')
    parser.add_argument('--population', type=int, default=30,
                        help='种群大小（默认30，建议20-50）')
    parser.add_argument('--strategy-file', type=str, default='best_ga_strategy.pkl',
                        help='策略文件路径')
    parser.add_argument('--no-gui', action='store_true',
                        help='测试时不使用GUI')
    
    args = parser.parse_args()
    
    print("="*70)
    print("遗传算法交通策略优化系统 - 改进版")
    print("="*70)
    print("主要改进:")
    print("  ✓ 更精细的状态空间（40个状态）")
    print("  ✓ 连续加速度控制（实数编码）")
    print("  ✓ 增强的碰撞检测和安全评估")
    print("  ✓ 自适应遗传算法参数")
    print("  ✓ 多样性保护机制")
    print("  ✓ 智能初始化策略")
    print("="*70)
    
    if args.mode == 'train' or args.mode == 'both':
        # 训练模式
        print(f"\n开始训练模式...")
        print(f"参数设置: 代数={args.generations}, 种群大小={args.population}")
        
        best_strategy = train_ga_strategy(
            generations=args.generations,
            population_size=args.population
        )
        
        if args.mode == 'both':
            print("\n训练完成，开始测试...")
            input("按回车键开始测试（将打开SUMO GUI）...")
            test_strategy(best_strategy, use_gui=not args.no_gui)
    
    elif args.mode == 'test':
        # 测试模式：加载已有策略
        # 先确保关闭任何旧连接
        try:
            traci.close()
        except:
            pass
        
        try:
            print(f"\n加载策略文件: {args.strategy_file}")
            strategy = GeneticTrafficStrategy.load(args.strategy_file)
            test_strategy(strategy, use_gui=not args.no_gui)
        except FileNotFoundError:
            print(f"\n错误: 找不到策略文件 {args.strategy_file}")
            print("请先运行训练: python ga_crossroad_runner.py --mode train")
        except Exception as e:
            print(f"\n错误: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "="*70)
    print("程序执行完毕")
    print("="*70)

